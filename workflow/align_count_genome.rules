import pandas as pd
import os
configfile: "configs/config_main.yaml"

samples = pd.read_csv(config["METAFILE"], sep = '\t', header = 0)['sample']
trimmed = config["TRIMMED"]
if trimmed == "yes" or trimmed == True:  
    input_path = config["BIGDATAPATH"] + "/" + config["PROJECT"] + "/trim"
else:
    input_path = config["READSPATH"]
key = config["KEY"]
end = config["END"]
mapper = config["ALIGNER"]
intermediate_path = config["BIGDATAPATH"] + "/" + config["PROJECT"] + "/mapping_" + mapper
index_path = config["INDEXPATH"]
index_base = config["INDEXBASE"]
final_path = config["RESULTPATH"] + "/" + config["PROJECT"] + "/mapping_" + mapper
counter = config["COUNTER"]
bwStranded = config["BWSTRANDED"]
main_path = config["MAINPATH"]
strand = config["STRAND"]

if input_path[0] != "/": 
    input_path = os.getcwd()+"/"+input_path

if intermediate_path[0] != "/": 
    intermediate_path = os.getcwd()+"/"+intermediate_path

if final_path[0] != "/": 
    final_path = os.getcwd()+"/"+final_path

if bwStranded == "no" or bwStranded==False: 
    rule end:
        input:
            report = final_path + "/report_align_count_"+counter+".html",
            bw = expand(final_path + "/bw/{sample}.bw", sample = samples),
            pca = final_path + "/counting_"+ counter + "/PCA.pdf"
if bwStranded == "yes" or bwStranded==True:
    rule end:
        input:
            pca = final_path + "/counting_"+ counter + "/PCA.pdf",
            report = final_path + "/report_align_count_"+counter+".html",
            bw_fw = expand(final_path + "/bw_str/{sample}_fw.bw", sample=samples),
            bw_rv = expand(final_path + "/bw_str/{sample}_rv.bw", sample=samples)
if bwStranded == "both":
    rule end:
        input:
            pca = final_path + "/counting_"+ counter + "/PCA.pdf",
            report = final_path + "/report_align_count_"+counter+".html",
            bw_fw = expand(final_path + "/bw_str/{sample}_fw.bw", sample=samples),
            bw_rv = expand(final_path + "/bw_str/{sample}_rv.bw", sample=samples),
            bw = expand(final_path + "/bw/{sample}.bw", sample = samples)

if end == "pair":
    rule getReads:
        output:
            fw = temp(intermediate_path + "/reads/{sample}_fw.fastq.gz"),
            rv = temp(intermediate_path + "/reads/{sample}_rv.fastq.gz")
        params:
            key = key,
            input_path = input_path
        run:
            shell("ln -s {params.input_path}/{wildcards.sample}_*R1*.f*q.gz {output.fw}"),
            shell("ln -s {params.input_path}/{wildcards.sample}_*R2*.f*q.gz {output.rv}")

else:
    rule getReads:
        output:
            read = temp(intermediate_path + "/reads/{sample}.fastq.gz")
        params:
            key = key,
            input_path = input_path
        run:
            shell("ln -s {params.input_path}/{wildcards.sample}*.f*q.gz {output.read}")

if mapper == "hisat2":

    rule spliceSites:
        output:
            splicesites = intermediate_path + "/splicesites.txt"
        conda:
            "env.yaml"
        shell:
            "hisat2_extract_splice_sites.py {config[ANNOTATION]} > {output.splicesites}"

    if end == "pair":
        rule hisat2:
            input:
                splicesites = intermediate_path + "/splicesites.txt",
                fw = intermediate_path + "/reads/{sample}_fw.fastq.gz",
                rv = intermediate_path + "/reads/{sample}_rv.fastq.gz"
            output:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam"
            conda:
                "env.yaml"
            params:
                index = index_path +"/" + index_base
            benchmark:
                intermediate_path + "/benchmarks/{sample}.hisat2.benchmark.txt"
            shell:
                "hisat2 -p {config[NCORE]} --known-splicesite-infile {input.splicesites} -x {params.index} -1 {input.fw} -2 {input.rv} | samtools sort -O BAM > {output.sort}"
    else:
        rule hisat2:
            input:
                splicesites = intermediate_path + "/splicesites.txt",
                fw = intermediate_path + "/reads/{sample}.fastq.gz"
            output:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam"
            conda:
                "env.yaml"
            params:
                index = index_path +"/" + index_base
            benchmark:
                intermediate_path + "/benchmarks/{sample}.hisat2.benchmark.txt"
            shell:
                "hisat2 -p {config[NCORE]} --known-splicesite-infile {input.splicesites} -x {params.index} -U {input.fw} | samtools sort -O BAM > {output.sort}"
            
    
elif mapper == "STAR":
    
    if end == "pair":
        rule star:
            input:
                fw = intermediate_path + "/reads/{sample}_fw.fastq.gz",
                rv = intermediate_path + "/reads/{sample}_rv.fastq.gz",
                annotation = config["ANNOTATION"]
            output:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
                counts = intermediate_path + "/bamFileSort/{sample}.ReadsPerGene.out.tab"
            conda:
                "env.yaml"
            params:
                index = index_path,
                basename = intermediate_path + "/bamFileSort/{sample}."
            benchmark:
                intermediate_path + "/benchmarks/{sample}.star.benchmark.txt"
            shell:
                "STAR --readFilesCommand zcat --outFileNamePrefix {params.basename} --runMode alignReads  --runThreadN {config[NCORE]} --quantMode GeneCounts TranscriptomeSAM --sjdbGTFfile {input.annotation} --outSAMtype BAM SortedByCoordinate --genomeDir {params.index} --readFilesIn  {input.fw} {input.rv} && mv {params.basename}Aligned.sortedByCoord.out.bam {output.sort}"
                
    else:
        rule star:
            input:
                fw = intermediate_path + "/reads/{sample}.fastq.gz", 
                annotation = config["ANNOTATION"]
            output:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
                counts = intermediate_path + "/bamFileSort/{sample}.ReadsPerGene.out.tab"
            conda:
                "env.yaml"
            params:
                index = index_path,
                basename = intermediate_path + "/bamFileSort/{sample}."
            benchmark:
                intermediate_path + "/benchmarks/{sample}.star.benchmark.txt"
            shell:
                "STAR --readFilesCommand zcat --outFileNamePrefix {params.basename} --runMode alignReads  --runThreadN {config[NCORE]} --quantMode GeneCounts TranscriptomeSAM --sjdbGTFfile {input.annotation} --outSAMtype BAM SortedByCoordinate --genomeDir {params.index} --readFilesIn  {input.fw} && mv {params.basename}Aligned.sortedByCoord.out.bam {output.sort}"


rule BamIndex:
    input:
        sort = intermediate_path + "/bamFileSort/{sample}.sort.bam"
    output:
        bai = intermediate_path + "/bamFileSort/{sample}.sort.bam.bai"
    conda:
        "env.yaml"
    shell:
        "samtools index {input.sort}"


if bwStranded == "yes" or bwStranded == "both" or bwStranded==True:
    rule BigWigF:
        input:
            sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
            bai = intermediate_path + "/bamFileSort/{sample}.sort.bam.bai"
        output:
            bw_fw = final_path + "/bw_str/{sample}_fw.bw"
        conda:
            "env.yaml"
        shell:
            "bamCoverage -b {input.sort} --filterRNAstrand forward -o {output.bw_fw} -p max"
            
    rule BigWigR:
        input:
            sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
            bai = intermediate_path + "/bamFileSort/{sample}.sort.bam.bai"
        output:
            bw_rv = final_path + "/bw_str/{sample}_rv.bw"
        conda:
            "env.yaml"
        shell:
            "bamCoverage -b {input.sort} --filterRNAstrand reverse -o {output.bw_rv} -p max"

    

if bwStranded == "no" or bwStranded == "both" or bwStranded==False:
    rule BigWig:
        input:
            sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
            bai = intermediate_path + "/bamFileSort/{sample}.sort.bam.bai"
        output:
            bw = final_path + "/bw/{sample}.bw"
        conda:
            "env.yaml"
        shell:
            "bamCoverage -b {input.sort} -o {output.bw} -p max"

rule alignmentQC:
    input:
        sort = intermediate_path + "/bamFileSort/{sample}.sort.bam"
    output:
        bamqc = directory(final_path + "/alignmentQC/{sample}_BAMqc")
    conda:
        "env.yaml"
    shell:
        "qualimap bamqc -bam {input.sort} -nt {config[NCORE]} --java-mem-size=6G -outdir {output.bamqc}"


if counter == "featureCounts":
    if end == "pair":
        rule featureCount:
            input:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
                annotation = config["ANNOTATION"]
            output:
                countF = final_path + "/counting_"+ counter + "/countTables/{sample}_count.tsv",
                WholeTable = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv",
                count_summary = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary"
            conda:
                "env.yaml"
            shell:
                "featureCounts -p -T {config[NCORE]} -t {config[FEATURE]} -g {config[ATTRIBUTE]} -a {input.annotation} -o {output.WholeTable} {input.sort} && tail -n +3 {output.WholeTable} | cut -f1,7 > {output.countF}"
    else :
        rule featureCount:
            input:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
                annotation = config["ANNOTATION"]
            output:
                countF = final_path + "/counting_"+ counter + "/countTables/{sample}_count.tsv",
                WholeTable = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv",
                count_summary = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary"
            conda:
                "env.yaml"
            shell:
                "featureCounts -T {config[NCORE]} -t {config[FEATURE]} -g {config[ATTRIBUTE]} -a {input.annotation} -o {output.WholeTable} {input.sort} && tail -n +3 {output.WholeTable} | cut -f1,7 > {output.countF}"

if counter == "htseq-count":
    if end == "pair":
        rule htseqCount:
            input:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
                annotation = config["ANNOTATION"]
            output:
                countF = final_path + "/counting_"+ counter + "/countTables/{sample}_count.tsv",
                count_summary = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary",
                tmp = temp(final_path + "/counting_"+ counter + "/countTables/{sample}_count.tmp")
            conda:
                "env.yaml"
            shell:
                "htseq-count -r pos -f bam -i {config[ATTRIBUTE]} -s {config[STRAND]} -t {config[FEATURE]} -c {output.tmp} {input.sort} {input.annotation} && sed '/^__/ d' {output.tmp} > {output.countF} && grep '__' {output.tmp} > {output.count_summary}"
    else: 
        rule htseqCount:
            input:
                sort = intermediate_path + "/bamFileSort/{sample}.sort.bam",
                annotation = config["ANNOTATION"]
            output:
                countF = final_path + "/counting_"+ counter + "/countTables/{sample}_count.tsv",
                count_summary = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary",
                tmp = temp(final_path + "/counting_"+ counter + "/countTables/{sample}_count.tmp")
            conda:
                "env.yaml"
            shell:
                "htseq-count -f bam -i {config[ATTRIBUTE]} -s {config[STRAND]} -t {config[FEATURE]} -c {output.tmp} {input.sort} {input.annotation} && sed '/^__/ d' {output.tmp} > {output.countF} && grep '__' {output.tmp} > {output.count_summary}"

if counter == "STARcount": 
    if strand == "yes" or strand == True:
        rule starCount:
            input:
                counts = intermediate_path + "/bamFileSort/{sample}.ReadsPerGene.out.tab"
            output:
                countF = final_path + "/counting_" + counter + "/countTables/{sample}_count.tsv",
                count_summary = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary"
            shell:
                "grep N_ {input.counts} > {output.count_summary} && sed '/N_/ d' {input.counts} | awk '{{print $1\"\t\"$3}}' > {output.countF}"
    if strand == "no" or strand == False: 
        rule starCount:
            input:
                counts = intermediate_path + "/bamFileSort/{sample}.ReadsPerGene.out.tab"
            output:
                countF = final_path + "/counting_"+ counter + "/countTables/{sample}_count.tsv",
                count_summary = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary"
            shell:
                "grep N_ {input.counts} > {output.count_summary} && sed '/N_/ d' {input.counts} | awk '{{print $1\"\t\"$2}}' > {output.countF}"
    if strand == "reverse":
        rule starCount:
            input:
                counts = intermediate_path + "/bamFileSort/{sample}.ReadsPerGene.out.tab"
            output:
                countF = final_path + "/counting_"+ counter + "/countTables/{sample}_count.tsv",
                count_summary = final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary"
            shell:
                "grep N_ {input.counts} > {output.count_summary} && sed '/N_/ d' {input.counts} | awk '{{print $1\"\t\"$4}}' > {output.countF}"


rule PCA:
    input:
        countF = expand(final_path + "/counting_"+ counter + "/countTables/{sample}_count.tsv", sample=samples)
    output:
        pca = final_path + "/counting_"+ counter + "/PCA.pdf"
    conda:
        "env.yaml"
    params:
        count_path = final_path + "/counting_"+ counter + "/countTables",
        mp = main_path
    shell:
        "Rscript {params.mp}scripts/pca.R {params.count_path}"

if counter == "htseq-count" or counter == "featureCounts":
    rule summaryReport:
        input:
            countF =  expand(final_path + "/counting_"+ counter + "/countTables/{sample}_table.tsv.summary", sample = samples), 
            bamqc = expand(final_path + "/alignmentQC/{sample}_BAMqc", sample = samples)
        output:
            report = final_path + "/report_align_count_"+counter+".html"
        conda:
            "env.yaml"
        shell:
            "multiqc {input.bamqc} {input.countF} --filename {output.report}"

if counter =="STARcount": 
    rule summaryReport:
        input:
            counts = expand(intermediate_path + "/bamFileSort/{sample}.ReadsPerGene.out.tab", sample = samples),
            bamqc = expand(final_path + "/alignmentQC/{sample}_BAMqc", sample = samples)
        output:
            report = final_path + "/report_align_count_"+counter+".html"
        conda:
            "env.yaml"
        params:
            mapping = intermediate_path + "/bamFileSort/",
        shell:
            "multiqc {params.mapping} {input.bamqc} --filename {output.report}"


